********************************************************************************
* Moteur de jeu (TO8 Thomson) - Benoit Rousseau 07/10/2020
* ------------------------------------------------------------------------------
*
*
********************************************************************************

(main)MAIN
	ORG $6300

********************************************************************************  
* Référence des variables globales
********************************************************************************
EXO_SRC            EQU $6101
EXO_DST            EQU $6105 
DK_DST             EQU $6222
WAIT_VBL_SWAP_PAGE EQU $61BF

********************************************************************************  
* Boucle principale
********************************************************************************

MAINLOOP
   JSR    WAIT_VBL_SWAP_PAGE
   BRA    MAINLOOP

********************************************************************************  
* Ordre des niveaux de jeu
* Octet 1: Zone (niveau de jeu qui nécessite un chargement disquette)
* Octet 2: Acte (sous-niveau de jeu qui ne nécessite pas d'accès disquette)
********************************************************************************
LEVEL_ORDER                 * level.order=AIZ:0;AIZ:1;MZ:0
   FDB    $0000
   FDB    $0001
   FDB    $0100
   
LEVEL_DEFINITION
   FDB    $

* sprite=sonic;./input/SPRITE/sonic.properties
* sprite=tails;./input/SPRITE/tails.properties
* sprite=crabmeat;./input/SPRITE/crabmeat.properties
* sprite=eggmobile;./input/SPRITE/eggmobile.properties

* # Déclaration du code nécessaire au niveau
* code=fadeout;./input/CODE/FADEOUT.ASM

* # AIZ ACT0 - Angel Island Zone Act 0
* 0.engine.init=image;palette
* 0.engine.run=crabmeat;tail;sonic
* 0.engine.end=fadeout
* 0.engine.image=./input/LEVEL/AIZ/AIZ_BACKGROUND.png
* 0.engine.palette=./input/LEVEL/AIZ_BACKGROUND.png;3
* 0.fadeout=0;0;0;0;16
* 0.sonic=0;0;20;150
* 0.tail=0;0;10;150
* 0.crabmeat=0;0;40;150
* 0.crabmeat=0;250;45;150
* 0.crabmeat=1;244;50;150

* # AIZ ACT1 - Angel Island Zone Act 1
* 1.engine.init=image;palette
* 1.engine.run=crabmeat;tail;sonic
* 1.engine.end=fadeout
* 1.engine.image=./input/LEVEL/AIZ/AIZ_BACKGROUND.png
* 1.engine.palette=./input/LEVEL/AIZ_BACKGROUND.png;3
* 1.fadeout=0;0;0;0;16
* 1.sonic=0;0;20;150
* 1.tail=0;0;10;150
* 1.crabmeat=0;0;40;150
* 1.eggmobile=0;250;45;150


* code=./input/SPRITE/SONIC/SONIC.ASM
SPRITE
   FCB    $00               * page code du sprite
   FDB    $0000             * adresse code du sprite

Table des variables d'un objet OST Object Status Table (xx octets par ligne):
obType      equ 0   ; type d'objet (00: sonic, 01: tails, 02: score, 03: ennemi1, ...)
obRender:   equ 1   ; on-screen (00:yes FF:no) => codage sur un bit ?
obX:        equ 2   ; x-axis position (1 bytes)
obSubX:     equ 3   ; x-axis subpixel position (1 bytes) => SONIC_X_SPS		FDB $0000	* Subpixel X speed (reliquat entre deux frames)
obY:        equ 4   ; y-axis position (1 bytes)
obSubY:     equ 5   ; y-axis subpixel position (1 bytes) => SONIC_Y_SPS		FDB $0000	* Subpixel Y speed (reliquat entre deux frames)
obVelX:     equ 6   ; x-axis velocity (1 bytes)          => SONIC_X_SPEED	FDB $0000	* Horizontal Speed
obVelY:     equ 7   ; y-axis velocity (1 bytes)          => SONIC_Y_SPEED	FDB $0000	* Vertical Speed
obInertia:  equ 8   ; Ground velocity (inertia) (2 bytes)=> SONIC_G_SPEED	FDB $0000	* Ground Speed First byte : Frame, Second byte : 1/256 Frame
obWidth:    equ 9   ; width/2 Vertical radius of the object's hitbox
obHeight:   equ 10  ; height/2 Horizontal radius of the object's hitbox
obPriority: equ 11  ; sprite stack priority -- 0 is front
obActWid:   equ 12  ; Horizontal radius of the object's visible sprite (action width)

obFrame:    equ $1A ; current frame displayed                 HERO_ANIMATION_IMC		FCB $00		* Animation courante - Image courante (doit etre suivi de RTN_IMC)
     => permet de tester l'image affichée (ex pour une porte: ouverte ou fermée)
     => A modifier quand on veut intervenir sur l'image affichée, ex: lancer une animation a une image donnée
obAniFrame: equ $1B ; current frame in animation script
obAnim:     equ $1C ; current animation                       HERO_ANIMATION_ADR		FDB $0000	* Animation courante - Pointeurs Adresse
     => Permet de tester l'animation courante en comparant à une ref d'animation
     => A modifier quand on veut changer d'animation
obNextAni:  equ $1D ; next animation
obTimeFrame:    equ $1E ; time to next frame                  HERO_ANIMATION_FRR		FCB $00		* Animation courante - Frames restante
obDelayAni: equ $1F ; time to delay animation
obAniPage (ajout):  HERO_ANIMATION_PAG		FCB $00		* Animation courante - Pointeur Page actif
obAniDraw (ajout):  HERO_ANIMATION_DRW		FDB $0000	* Animation courante - Pointeur Dessin
obAniDel  (ajout):  HERO_ANIMATION_DEL		FDB $0000	* Animation courante - Pointeur Effacement

obColType:  equ $20 ; collision response type
obColProp:  equ $21 ; collision extra property
obStatus:   equ $22 ; orientation or mode
obRespawnNo:    equ $23 ; respawn list index number
obRoutine:  equ $24 ; routine number                   => code a executer, collision ?
ob2ndRout:  equ $25 ; secondary routine number
obAngle:    equ $26 ; angle
obSubtype:  equ $28 ; object subtype
obSolid:    equ ob2ndRout ; solid status flag
  

* animation=SONIC_IDLE_L;24;ABS;SIL:0;GO;SONIC_IDLE_L;0;0
* animation=SONIC_IDLE_R;24;ABS;SIR:0;GO;SONIC_IDLE_R;0;0
* animation=SONIC_WALK_L;6;GSP;SWL:0;SWL:1;SWL:2;SWL:3;SWL:4;SWL:5;SWL:6;SWL:7;SWL:8;SWL:9;SWL:10;SWL:11;GO;SONIC_WALK_L;0;0
* animation=SONIC_WALK_R;6;GSP;SWR:0;SWR:1;SWR:2;SWR:3;SWR:4;SWR:5;SWR:6;SWR:7;SWR:8;SWR:9;SWR:10;SWR:11;GO;SONIC_WALK_R;0;0
* animation=SONIC_JOG_L;6;GSP;SOL:0;SOL:1;SOL:2;SOL:3;SOL:4;SOL:5;SOL:6;SOL:7;SOL:8;SOL:9;GO;SONIC_RUN_L;0;0
* animation=SONIC_JOG_R;6;GSP;SOR:0;SOR:1;SOR:2;SOR:3;SOR:4;SOR:5;SOR:6;SOR:7;SOR:8;SOR:9;GO;SONIC_RUN_R;0;0
* animation=SONIC_JUMP_L;4;GSP;SJL:0;SJL:1;SJL:2;SJL:3;SJL:0;SJL:1;SJL:4;SJL:5;SJL:0;SJL:1;SJL:6;SJL:7;SJL:0;SJL:1;SJL:8;SJL:9;GO;SONIC_JUMP_L;0;0
* animation=SONIC_JUMP_R;4;GSP;SJR:0;SJR:1;SJR:2;SJR:3;SJR:0;SJR:1;SJR:4;SJR:5;SJR:0;SJR:1;SJR:6;SJR:7;SJR:0;SJR:1;SJR:8;SJR:9;GO;SONIC_JUMP_R;0;0
   
   
   Les scripts d'animation suivants sont a mettre dans le code du sprite :
   
	FDB $0018		* 00 : Absolute - !=00 : NbFrames relative to GSP - 18 : Nb frames par image
HERO_IDLE_L (obAnim)
	FCB $01			* Page associee a l adresse drw img 00
	FDB $A000		* Adresse drw img 00
	FDB $A000		* Adresse del img 00
	FCB $FF			* FF SET return Anim et Image BRANCH Anim et Image
	FDB HERO_IDLE-C * adresse animation cible
	FDB $0301		* 03 image cible 01 image retour
	FCB $FE			* FE RETURN
	
	Nouveau format:
	
	$18 *speed
	$00 *id image
	$00 *id image
	$00 *id image
	$FF *boucle au début (afEnd) $FE *retourne x images en arriere (afBack) $FD *change d'animation (afChange)
	$00 *sous image cible afback (0 pour boucle, derniere image pour freeze)
	
; Animation flags
afEnd:      equ $FF ; return to beginning of animation
afBack:     equ $FE ; go back (specified number) bytes
afChange:   equ $FD ; run specified animation
afRoutine:  equ $FC ; increment routine counter
afReset:    equ $FB ; reset animation and 2nd object routine counter
af2ndRoutine:   equ $FA ; increment 2nd routine counter
	
	
	
	
	image ref:
	$00 * id image
	$04 * page
	$A000 * adresse draw
	$A000 * adresse del
	
	* best practice : positionner en nb de frame la duree la plus faible pour une image, pour les autres on repette plusieur fois l'image.
	* ex: durée 4, img1, img1, img1, img2, img2, img3 => 7 octets on ne perd pas trop
	*  sinon il faudrait 12, img1, 8, img2, 4, img3 => 6 cycles
	* mais gain si vitesse constante : on garde donc ce principe
	
	


