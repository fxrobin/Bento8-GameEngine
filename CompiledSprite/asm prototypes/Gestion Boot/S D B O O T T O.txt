/**************************************************\
*               S D B O O T T O                    * 
*           (c) 2013 - Daniel Coulom               *  
*           http://dcmoto.free.fr/                 *
*           http://forum.system-cfg.com/           *
*--------------------------------------------------*
* Ce code est distribue gratuitement dans l'espoir *
* qu'il sera utile, mais sans aucune  garantie  et *
* sans  engager  la  responsabilité  de  l'auteur. *
* Vous  pouvez  l' utiliser,  le  modifier  et  le *
* diffuser librement, en conservant cette  licence *
* et les références de l'auteur dans   toutes  les *
* copies. L'exploitation commerciale est interdite.*
\**************************************************/

* Ce programme fait partie du projet SDMOTO
* Il réalise les fonctions suivantes pour les
* ordinateurs TO :
* - initialisation de la carte SD ou SDHC
* - chargement du secteur de boot en $6200
* - lancement de l'exécution de ce secteur
* Parametre en entree :
* - CMD17+1 = adresse bloc dans la carte SD
*
* Il n'y a pas de traitement d'erreur pour garder
* le programme aussi court que possible. Quand la 
* carte ne peut pas être initialisee l'ordinateur
* reste bloque.
*
* Utilisation du 2eme port joystick
* Port A ($E7CC)
* PA5 en sortie --> SD Clock     SCK  DB9 pin 2
* PA6 en sortie --> SD Data IN   MOSI DB9 pin 3
* PA7 en entree <-- SD Data OUT  MISO DB9 pin 4
*

/**************************************************\
*                Version 2014.08.13                *
\**************************************************/
* Historique
* 2014.08.13 premiere version operationnelle

  ORG   $6400

*------------------------------------------------------
* CONFIGURATION PIA 6821 POUR ACCES A LA CARTE SD
*------------------------------------------------------
  ORCC  #$50          desactive les interruptions 
  LDS   #$60CC        initialisation pile systeme
  LDA   #$E7          valeur initialisation DP
  TFR   A,DP          modifie DP pour acces carte SD
  LDA   <$CE          lecture registre de controle A
  ANDA  #$FB          raz bit 2 
  STA   <$CE          selection DDRA
  LDB   #$60          set bits 5 et 6
  STB   <$CC          bits MOSI et CLOCK en sortie
  ORA   #$04          set b2
  STA   <$CE          selection PA
  LDB   #$40          set bit 6
  STB   <$CC          keep the DIN high

*------------------------------------------------------
* CMD0 = SOFTWARE RESET
* Precedee de l'envoi de 80 tops d'horloge
* Pas de test en cas d erreur
*------------------------------------------------------
POWER
  LDX   #$000A        nombre d'envois de 8 tops
POWER1  
  BSR   RBYTE         envoi de 8 tops horloge
  LEAX  -1,X          decrementation compteur
  BNE   POWER1        nouvel envoi
  LEAU  CMD0,PCR      commande CMD0
  BSR   EXCMD0        execution commande sans attente

*------------------------------------------------------
* CMD8 = SEND INTERFACE CONDITION
* Non reconnue par les cartes SD de version < 2.00
* c'est pourquoi le code retour n'est pas teste.
* Lire les 4 derniers octets de la reponse R7
*------------------------------------------------------
  BSR   EXCMD         execution commande 
  BSR   RBYTE         lecture octet 
  BSR   RBYTE         lecture octet 
  BSR   RBYTE         lecture octet 
  BSR   RBYTE         lecture octet 

*------------------------------------------------------
* CMD55 + ACMD41 = INITIALISATION
* Retry en cas de code retour different de zero
*------------------------------------------------------
INITSD
  LEAU  CMD55,PCR     adresse commande CMD55
  BSR   EXCMD         execution commande CMD55
  BSR   EXCMD         execution commande ACMD41
  BCS   INITSD        carte non prete, nouvel essai

*------------------------------------------------------
* LECTURE D'UN BLOC EN $6200 ET EXECUTION
*------------------------------------------------------
LOAD
  BSR   EXCMD         execution commande
LOAD1
  BSR   RBYTE         lecture d'un octet
  CMPA  #$FE          comparaison avec $FE
  BNE   LOAD1         attente debut secteur
  LDY   #$6200        adresse de chargement 
LOAD2
  BSR   RBYTE         lecture d'un octet
  STA   ,Y+           stockage dans le buffer
  CMPY  #$6400        test fin de chargement
  BNE   LOAD2         nouvelle lecture
  BSR   RBYTE         lecture CRC1
  BSR   RBYTE         lecture CRC2
  JMP   $6200         execution 

*------------------------------------------------------
* ATTENTE CARTE PRETE PUIS EXECUTION D'UNE COMMANDE
*------------------------------------------------------
EXCMD
  BSR   RBYTE         lecture d'un octet
  INCA                ajout de 1 ($FF --> $00) 
  BNE   EXCMD         attente carte prete

*------------------------------------------------------
* EXECUTION D'UNE COMMANDE POUR LA CARTE SD
* Le registre B n'est pas preserve.
* le code retour est dans le registre A
*------------------------------------------------------
EXCMD0
  LDX   #$0006        nombre d'octets de commande
EXCMD2
  LDA   ,U+           chargement octet de commande
  BSR   WBYTE         ecriture de l'octet
  LEAX  -1,X          decrementation compteur
  BNE   EXCMD2        il reste des octets a envoyer
EXCMD3
  BSR   ALIGN         lecture d'un octet aligne  
  CMPA  ,U+           test code de retour
  BEQ   EXCMD4        code bon
  COMA                carry set en erreur
  RTS                 retour
EXCMD4
  CLRA                clear carry
  RTS                 retour

*------------------------------------------------------
* LECTURE D'UN OCTET AVEC ALIGNEMENT SUR BIT 0 (SDMOTO)
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
ALIGN
  CLRA                compteur pour 256 boucles
ALIGN1
  LDB   #$7F          Valeur pour test bit 7
  STB   <$CC          clock high, di high 
  CMPB  <$CC          PA b7 (bit lu) -> carry 
  LDB   #$5F          clear bit 5
  STB   <$CC          clock low, di high
  BCS   ALIGN2        si bit 1, continuer a lire
  LDA   #$FC          sinon stocker bit 0
  BRA   RBYTE1        lire les 7 autres bits
ALIGN2
  DECA                decrementer compteur
  BNE   ALIGN1        nouvelle lecture

*------------------------------------------------------
* LECTURE D'UN OCTET (SDMOTO)
* 2 + 8 * 21 + 5 = 175 cycles
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation du compteur de boucle par Samuel
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
RBYTE
  LDA   #$FE          b0 marqueur fin de boucle (2)
RBYTE1      
  LDB   #$7F          Valeur pour test bit 7    (2)
  STB   <$CC          clock high, di high       (4)
  CMPB  <$CC          PA b7 (bit lu) -> carry   (4)
  LDB   #$5F          clear bit 5               (2)
  STB   <$CC          clock low, di high        (4)
  ROLA                C (bit lu) -> b0 reg A    (2)
  BCS   RBYTE1        suite de la boucle        (3) 
  RTS                 retour (octet dans A)     (5)

*------------------------------------------------------
* ECRITURE D'UN OCTET POUR SDMOTO
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en entree
*------------------------------------------------------
WBYTE
  LDB   #$08          compteur de boucles = 8
  PSHS  B             empilage compteur de boucles
WBYTE1
  ASLA                b7 reg A -> carry
  RORB                carry -> b7 reg B
  LSRB                b7 reg B -> b6 reg B
  STB   <$CC          envoi bit vers DI
  ORB   #$20          set bit 5
  STB   <$CC          clock high
  ANDB  #$DF          clear bit 5
  STB   <$CC          clock low
  DEC   ,S            decremente compteur boucles
  BNE   WBYTE1        nouvelle boucle
  ORB   #$40          set bit 6
  STB   <$CC          keep the DIN high
  PULS  B,PC          retour

*------------------------------------------------------
* COMMANDES CARTE SD
*------------------------------------------------------
CMD0
  FCB   $40           go iddle state
  FDB   $0000
  FDB   $0000
  FCB   $95           checksum obligatoire           
  FCB   $01           code retour attendu  
*------------------------------------------------------
CMD8
  FCB   $48           send interface condition
  FDB   $0000
  FDB   $01AA
  FCB   $87           checksum obligatoire  
  FCB   $00           code retour attendu  
*------------------------------------------------------
CMD55
  FCB   $77           application command
  FDB   $0000
  FDB   $0000
  FCB   $FF           checksum non testee  
  FCB   $00           code retour attendu  
*------------------------------------------------------
AC41
  FCB   $69           activate card initialization 
  FDB   $4000
  FDB   $0000 
  FCB   $FF           checksum non testee  
  FCB   $00           code retour attendu  
*------------------------------------------------------
CMD17
  FCB   $51           read single block
  FDB   $0000         adresse bloc (poids fort)
  FDB   $0000         adresse bloc (poids faible)
  FCB   $00           checksum non testee
  FCB   $00           code retour attendu  
*------------------------------------------------------

  END