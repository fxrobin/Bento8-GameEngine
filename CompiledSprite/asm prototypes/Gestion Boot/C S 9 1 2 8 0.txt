/**************************************************\
*                 C S 9 1 2 8 0                    * 
*           (c) 2013 - Daniel Coulom               *  
*           http://dcmoto.free.fr/                 *
*           http://forum.system-cfg.com/           *
*--------------------------------------------------*
* Ce code est distribue gratuitement dans l'espoir *
* qu'il sera utile, mais sans aucune  garantie  et *
* sans  engager  la  responsabilité  de  l'auteur. *
* Vous  pouvez  l' utiliser,  le  modifier  et  le *
* diffuser librement, en conservant cette  licence *
* et les références de l'auteur dans   toutes  les *
* copies. L'exploitation commerciale est interdite.*
\**************************************************/

* Ce programme emule un controleur de disquette
* Thomson accedant a une image au format .sd par
* l'intermediaire des interfaces SDMOTO ou SDMO
* Il est destine a être charge dans l'eprom du
* controleur nanoreseau, dans les banques 0 et 1.
* La banque 0 accede a l'interface SDMOTO
* La banque 1 accede a l'interface SDMO
* Auteur : Daniel Coulom, d'après la rom CD90-640
* Calcul du LBA avec le code de Samuel Devulder
* Optimisation lecture octet par Samuel Devulder

/**************************************************\
*                Version 2014.03.01                *
\**************************************************/
* Historique
* 2014.03.01 pas de reset pour une carte déjà initialisee
* 2014.03.01 indicateur carte initialisee $55 en CMDXX+5
* 2014.02.27 initialisation mosi au niveau haut
* 2014.02.27 montee du signal d'horloge avant lecture bit
* 2014.02.27 EXCMD=attente octet $FF, EXCMD0=pas d'attente
* 2014.02.27 suppression retries d'initialisation carte
* 2014.02.21 abandon EXCMD si la carte n'est pas prete
* 2014.01.08 lecture systematique du LBA0 a chaque reset
* 2014.01.08 3 retries en cas d erreur initialisation SD
* 2014.01.08 abandon de la sortie de la boucle EXCMD
* 2014.01.06 sortie de la boucle EXCMD si carte non prete
* 2014.01.06 x 16 delai initialisation carte -> 1 seconde
* 2013.12.30 correction erreur de compilation cs91281
* 2013.12.21 correction bug de calcul adresse LB0 pour MO
* 2013.12.07 adresse fichier .sd lue sans buffer en ram
* 2013.12.07 suppression des retries lors du boot
* 2013.12.05 ajout fonctions $04 & $10 (selection densite)
* 2013.12.01 retablissement configuration port joysticks
* 2013.10.30 deroulement boucle ecriture octet dans SWRITE
* 2013.10.30 deroulement boucle lecture octet dans SREAD
* 2013.10.29 gain de 2 cycles dans RBYTE version SDMO
* 2013.10.21 suppression initialisation du CNA en sortie
* 2013.10.20 correction initialisation PIA musique et jeu
* 2013.10.19 indirection vers EXCMD en $A028-$E028 
* 2013.10.18 banque 0 ou 1 choisie par parametre -dBANK 
* 2013.10.17 suppression des retries fonctions standard
* 2013.10.17 retour erreur unite / piste / secteur
* 2013.10.10 formatage rapide pistes 0 et 20 seulement
* 2013.10.08 correction detection SDHC (BLS -> BPL)
* 2013.08.26 SB_LB0 decale de 2 octets (evite ecrasement)
* 2013.08.14 améliorations mineures
* 2013.08.11 procedure de reset pour TO8/TO8D/TO9/TO9+
* 2013.08.10 procedure de reset pour TO8D
* 2013.08.08 zones de travail en debut de pile systeme
* 2013.08.07 copie routine RBYTE dans SREAD evite BSR
* 2013.08.07 copie routine WBYTE dans SWRITE evite BSR
* 2013.08.07 test position switches pour choix SD_LB0
* 2013.08.06 buffer en $6300 pour lecture secteur 1
* 2013.08.06 routine CLOCK envoie 8 x A tops horloge
* 2013.08.06 attente carte prete avant envoi commande
* 2013.08.05 test OK en configuration reelle sur MO6
* 2013.08.05 temporisation entre ecritures secteurs
* 2013.08.05 correction erreur dans RECFI
* 2013.07.28 ecriture secteur et formatage OK dans dcmoto
* 2013.07.25 boot, chargement DOS, lecture secteur OK
* 2013.07.24 ajout du calcul LBA ecrit par sam
* 2013.07.23 debut du projet

*------------------------------------------------------
* VECTEURS EN RAM
*------------------------------------------------------
DK_OPC  EQU $6048   code commande controleur disquette
DK_DRV  EQU $6049   numero du lecteur de disquette
DK_TRK  EQU $604a   n° piste (2 octets)
DK_SEC  EQU $604c   n° secteur
DK_NUM  EQU $604d   entrelacement
DK_STA  EQU $604e   etat courant controleur disquette
DK_BUF  EQU $604f   adresse buffer secteur (2 octets)
* position tetes    n° piste + n° secteur (2 octets)
TRACK0  EQU $6051   position tete lecteur 0
TRACK1  EQU $6053   position tete lecteur 1
TRACK2  EQU $6055   position tete lecteur 2
TRACK3  EQU $6057   position tete lecteur 3
ROTAT   EQU $6058   indicateur de rotation du moteur
DKFLG   EQU $6080   indicateur presence controleur disque

* Zones de travail en pile systeme pour le driver de la carte SD
SD_LB0  EQU $608E   adresse du debut du fichier .sd dans la carte SD
SD_TYP  EQU $6092   type de carte SD=0 SDHC=1
CMDXX   EQU $6093   definition de la commande CMD17 ou CMD24
SD_LBA  EQU $6094   adresse du secteur courant dans la carte SD

DKWE5   EQU $60e5   ????
DKWE7   EQU $60e7   pointeur sur nom de fichier
DKWE9   EQU $60e9   pointeur sur buffer
DKWEB   EQU $60eb   type de fichier
DKWEC   EQU $60ec   flag de fichier 
DKWED   EQU $60ed   bloc libre dans la FAT
DKWF0   EQU $60f0   code operation logique
DKWF5   EQU $60f5   numero de secteur
DKWF6   EQU $60f6   numero de bloc  
DKWF7   EQU $60f7   nombre d'octets dans le dernier secteur du fichier
DKWF9   EQU $60f9   numero de bloc alloue
DKWFA   EQU $60fa   numero du premier secteur du bloc
DKWFB   EQU $60fb   numero de piste du bloc courant
BUFFER  EQU $6200   buffer de lecture/ecriture secteur

*------------------------------------------------------
* ROM DU CONTROLEUR
*------------------------------------------------------
  ORG $E000
  FCB $53        S  controleur carte SD     
  FCB $54        T  fat de 160 octets     
  FCB $44        D  double densite    
  FCB $40        7  checksum 53+54+44+55=140

OPTABL
  LBRA  DKCONT   fonctions standard      
  LBRA  DKBOOT   lancement du boot       
  LBRA  DKFMT    formatage               
  LBRA  LECFA    chargement de la fat    
  LBRA  RECFI    ouverture d'un fichier  
  LBRA  RECUP    effacement d'un fichier 
  LBRA  ECRSE    ecriture d'un secteur   
  LBRA  ALLOD    creation d'un fichier   
  LBRA  ALLOB    allocation d'un bloc    
  LBRA  MAJCL    mise a jour cluster     
  LBRA  FINTR    cloture d'ecriture      
  LBRA  RESETO   reset special TO8/TO8D/TO9/TO9+      
  LBRA  EXCMD    execution commande pour carte SD      

*------------------------------------------------------
* Initialisation des registres
*------------------------------------------------------
INIREG
  TFR   PC,D            adresse courante            
  ANDA  #$70            calcul valeur DP
  TFR   A,DP            DP = $20 ou $60
  RTS   
  
*------------------------------------------------------
* DKBOOT = Lancement du boot
*------------------------------------------------------
DKBOOT
  BSR  INIREG           initialisation DP       
  CLR   <DK_DRV         0 dans le numero de lecteur
DKB1
  CLR   <DK_TRK         toujours zero
  CLR   <DK_TRK+1       selection piste 0
  LDA   #$01            valeur pour secteur 1
  STA   <DK_SEC         selection secteur 1
  LBSR  RESET           initialisation carte SD
  BCS   DKB9            erreur d'initialisation
  LEAU  BUFFER,PCR      adresse du buffer secteur
  STU   <DK_BUF         stockage adresse buffer
  LBSR  SREAD           lecture secteur logique
  BCS   DKB9            erreur de lecture
  LEAU  BUFFER,PCR      adresse debut de buffer      
  LEAY  BUFFER+$7f,PCR  adresse fin de buffer
  PSHS  Y               empilage
  LDA   #$55            calcul checksum boot
DKB4
  DEC   ,U              octet - 1
  COM   ,U              complement
  ADDA  ,U+             ajout checksum
  CMPU  ,S              test fin de buffer
  BNE   DKB4            octet suivant
  PULS  Y     
  CMPA  ,U              test checksum boot
  BNE   DKB9            checksum fausse
  JMP   BUFFER,PCR      execute le boot
DKB9
  CLR   <DKFLG          Indicateur de presence controleur
  JMP   [$001e]         lancement application a froid

*------------------------------------------------------
* DKCONT = Fonctions standard
*------------------------------------------------------
DKCONT
  PSHS  U,Y,X,DP,B,A,CC                  
  BSR   INIREG          initialisation registres
  CLRA                  status=0
  PSHS  A               empile le status
  PULS  B               depile le status
  BSR   STDOP           execution de l'operation
  PULS  A               depile CC 
  EXG   A,CC            restaure CC
  LSRA                  bit d'erreur dans CC
  PULS  A,B,DP,X,Y,U,PC
  
*------------------------------------------------------
* Execution fonction standard
*------------------------------------------------------
STDOP
  LDA   <DK_OPC        Code operation  
  LEAY  >RESET,PCR     Reset controleur
  BITA  #$01           Bit reset
  BNE   STDOP2         Execution reset          
  LEAY  >SREAD,PCR     Lecture secteur logique
  BITA  #$02           Bit lecture secteur
  BNE   STDOP2         Execute lecture secteur   
  LEAY  >SWRITE,PCR    Ecriture secteur logique
  BITA  #$08           Bit ecriture secteur
  BNE   STDOP2         Execute lecture secteur 
  LEAY  >FIND0,PCR     Recherche piste 0
  BITA  #$20           Bit recherche piste 0
  BNE   STDOP2         Execute recherche piste 0
  LEAY  >FINDT,PCR     Recherche piste
  BITA  #$40           Bit recherche piste x
  BNE   STDOP2         Execute recherche piste x
  LEAY  >SIMPLE,PCR    Passage simple densite
  BITA  #$04           Bit passage simple densite
  BNE   STDOP2         Execute passage simple densite
  LEAY  >DOUBLE,PCR    Passage double densite
  BITA  #$10           Bit passage double densite
  BEQ   STDOP8         Erreur fonction inconnue           
STDOP2
  JSR   ,Y             Execution de la fonction
  BCC   STDOP9         Retour sans erreur           
STDOP8
  COMB                 Erreur dans CC
STDOP9
  RTS        

*------------------------------------------------------
* RESET SPECIAL POUR TO8/TO8D/TO9/TO9+
*------------------------------------------------------
RESETO
 IF &BANK=0
  ORCC  #$50         desactive les interruptions 
  LDA   #$60         valeur d'initialisation de DP
  TFR   A,DP         initialisation de DP
  BSR   RESET        initialise la carte SD
  LDS   #$60CC       initialise pointeur pile systeme
  LDB   #$DF         type de disque
  LDA   $FFFF        dernier octet rom
  CMPA  #$EE         test rom TO8 version 1
  BEQ   RESET8       reset TO8 version 1
  CMPA  #$C8         test rom TO8D et TO8 v2
  BEQ   RESETD       reset TO8D et TO8 v2
  CMPA  #$19         test rom TO9
  BEQ   RESET9       reset TO9 
  CMPA  #$A0         test rom TO9+
  BEQ   RESETP       reset TO9+ 
  JMP   [$FFFE]      sinon reset normal
RESET8
  JMP   $FE50        suite du reset du TO8 version 1
RESETD
  JMP   $FE4C        suite du reset du TO8D et TO8v2
RESET9
  JMP   $EC19        suite du reset du TO9 (provisoirement reset)
RESETP
  JMP   $FE29        suite du reset du TO9+
 ENDIF
  RTS

*--------------------------------
* Passage en simple densite
*--------------------------------
SIMPLE
  LDA   #$80
  BRA   DOUBLE+1

*--------------------------------
* Passage en double densite
*--------------------------------
DOUBLE
  CLRA  
  RTS   
    
*------------------------------------------------------
* RESET CARTE SD POUR INTERFACE SDMOTO OU SDMO
* Pas de reset si l'indicateur d'initialisation de
* la carte SD est positionne ($55 en CMDXX+5)
*------------------------------------------------------
RESET
  LDA   <CMDXX+5      indicateur reset carte SD
  CMPA  #$55          test indicateur de reset
  BNE   POWER         initialisation de la carte
  CLRA                clear carry
  RTS 

*---------------------------------
* Retour en erreur initialisation
*---------------------------------
INITERR
  BSR   RCONF         retablissement config PIA 6821 
  COMA                1 dans code condition
  RTS                 retour

*------------------------------------------------------
* RESTAURATION PIA 6821 EN CONFIGURATION STANDARD
*------------------------------------------------------
RCONF
 IF &BANK=0          
  LDA   <$CE          lecture registre de controle A
  ANDA  #$FB          raz bit 2 
  STA   <$CE          selection DDRA
  CLRB                tous les bits a zero  
  STB   <$CC          toutes les lignes en entree
  ORA   #$04          set b2
  STA   <$CE          selection PA
 ENDIF
  TFR   DP,A          valeur actuelle DP
  SUBA  #$87          soustraction de $87
  TFR   A,DP          retablir valeur initiale DP
  RTS

*------------------------------------------------------
* CONFIGURATION PIA 6821 POUR ACCES A LA CARTE SD
*------------------------------------------------------
SCONF 
  ORCC  #$50          desactive les interruptions 
  TFR   DP,A          lecture de DP
  ADDA  #$87          ajout de $87
  TFR   A,DP          modifie DP pour acces carte SD
 IF &BANK=0          
  LDA   <$CE          lecture registre de controle A
  ANDA  #$FB          raz bit 2 
  STA   <$CE          selection DDRA
  LDB   #$60          set bits 5 et 6
  STB   <$CC          bits MOSI et CLOCK en sortie
  ORA   #$04          set b2
  STA   <$CE          selection PA
  LDB   #$40          set bit 6
  STB   <$CC          keep the DIN high
 ELSE
  LDB   <$C0          valeur port A PIA systeme
  ORB   #$40          set bit 6
  STB   <$C0          keep the DIN high
 ENDIF
  RTS

*------------------------------------------------------
* CMD0 = SOFTWARE RESET
* Precedee de l'envoi de 80 tops d'horloge
* En cas d'erreur abandon de l'initialisation
*------------------------------------------------------
POWER
  BSR   SCONF         configuration PIA 6821
  LDA   #$0A          nombre d'appels de 8 tops
  LBSR  CLOCK         envoi de 10 fois 8 tops horloge 
  LEAU  CMD0,PCR      commande CMD0
  LBSR  EXCMD0        execution commande sans attente
  BCS   INITERR       erreur d'initialisation

*------------------------------------------------------
* CMD8 = SEND INTERFACE CONDITION
* Non reconnue par les cartes SD de version < 2.00
* c'est pourquoi le code retour n'est pas teste.
* Lire les 4 derniers octets de la reponse R7
*------------------------------------------------------
  LBSR  EXCMD         execution commande 
  LDA   #$04          nbre d'octets
  LBSR  CLOCK         envoi 4 fois 8 tops horloge 

*------------------------------------------------------
* CMD55 + ACMD41 = INITIALISATION
* Retry en cas de code retour different de zero
* Abandon apres 512 tentatives. 
*------------------------------------------------------
  LDY   #$0200        compteur pour 512 essais
INITSD
  LEAY  -1,Y          decrementation compteur
  BEQ   INITERR       erreur apres 512 essais
  LEAU  CMD55,PCR     adresse commande CMD55
  LBSR  EXCMD         execution commande CMD55
  LBSR  EXCMD         execution commande ACMD41
  BCS   INITSD        carte non prete, nouvel essai

*------------------------------------------------------
* CMD58 = LECTURE OCR
* Permet de determiner le type de carte SD ou SDHC
*------------------------------------------------------
GETOCR
  LBSR  EXCMD         execution commande
  BCS   INITERR       erreur commande
  CLR   SD_TYP,PCR    carte SD par defaut 
  LBSR  RBYTE         lecture OCR poids fort
  ASLA                isole le type de carte 
  BPL   GETOCR1       carte SD   : SD_TYP=0
  INC   SD_TYP,PCR    carte SDHC : SD_TYP=1
GETOCR1      
  LDA   #$03          pour 3 octets        
  LBSR  CLOCK         lecture OCR (octets 2, 3, 4)
  BSR   RCONF         retablissement config PIA 6821 

*------------------------------------------------------
* Initialisation de la commande CMDXX
* pour lire le deuxieme secteur de la carte SD
* Astuce: la checksum initialisee a $55 sert
* d'indicateur d'initialisation de la carte SD  
*------------------------------------------------------
RLBA1
  LDD   #$0000        debut adresse secteur 1
  STD   <SD_LBA       2 octets a zero 
  ORB   <SD_TYP       0=SD, 1=SDHC       
  BNE   RLBA2         LBA = $00000001 pour carte SDHC
  ORA   #$02          LBA = $00000200 pour carte SD
RLBA2               
  STD   <SD_LBA+2     2 octets adresse secteur
  LDD   #$5500        checksum et code retour
  STD   <CMDXX+5      2 derniers octets

*------------------------------------------------------
* Lecture adresse fichier .sd fonction des switches
*------------------------------------------------------
  LDA   #$51          code CMD17
  STA   <CMDXX        initialise le code commande  
  BSR   SCONF         configuration pour acces carte SD 
  LEAU  CMDXX,PCR     adresse CMD17
  LBSR  EXCMD         execution CMD17
RLBA3
  LBSR  RBYTE         lecture d'un octet
  CMPA  #$FE          comparaison avec $FE
  BNE   RLBA3         attente debut secteur
  LDA   $E7D8,PCR     lecture position switches
  ANDA  #$1F          selection intervalle 0-31
  LSLA                multiplie par 2 
  LSLA                multiplie par 2
  BEQ   RLBA4         switches a zero
  LBSR  CLOCK         lire A octets
RLBA4
  BSR   RBYTE         lire premier octet adresse
  STA   SD_LB0,PCR    stocker
  BSR   RBYTE         lire premier octet adresse
  STA   SD_LB0+1,PCR  stocker
  BSR   RBYTE         lire premier octet adresse
  STA   SD_LB0+2,PCR  stocker
  BSR   RBYTE         lire premier octet adresse
  STA   SD_LB0+3,PCR  stocker
  CLRA                compteur pour 256 octets
  LBSR  CLOCK         lire 256 octets de plus
  CLRA                compteur pour 256 octets
  LBSR  CLOCK         lire 256 octets de plus
  LBSR  RCONF         retablissement configuration 
  CLRA                0 dans code condition
  RTS                 retour

*------------------------------------------------------
* ATTENTE CARTE PRETE PUIS EXECUTION D'UNE COMMANDE
*------------------------------------------------------
EXCMD
  BSR   RBYTE         lecture d'un octet
  INCA                ajout de 1 ($FF --> $00) 
  BNE   EXCMD         attente carte prete

*------------------------------------------------------
* EXECUTION D'UNE COMMANDE POUR LA CARTE SD
* Le registre B n'est pas preserve.
* le code retour est dans le registre A
*------------------------------------------------------
EXCMD0
  LDX   #$0006        nombre d'octets de commande
EXCMD2
  LDA   ,U+           chargement octet de commande
  BSR   WBYTE         ecriture de l'octet
  LEAX  -1,X          decrementation compteur
  BNE   EXCMD2        il reste des octets a envoyer
EXCMD3
  BSR   ALIGN         lecture d'un octet aligne  
  CMPA  ,U+           test code de retour
  BEQ   EXCMD4        code bon
  COMA                carry set en erreur
  RTS                 retour
EXCMD4
  CLRA                clear carry
  RTS                 retour

 IF &BANK=0
*------------------------------------------------------
* ECRITURE D'UN OCTET POUR SDMOTO
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en entree
*------------------------------------------------------
WBYTE
  LDB   #$08          compteur de boucles = 8
  PSHS  B             empilage compteur de boucles
WBYTE1
  ASLA                b7 reg A -> carry
  RORB                carry -> b7 reg B
  LSRB                b7 reg B -> b6 reg B
  STB   <$CC          envoi bit vers DI
  ORB   #$20          set bit 5
  STB   <$CC          clock high
  ANDB  #$DF          clear bit 5
  STB   <$CC          clock low
  DEC   ,S            decremente compteur boucles
  BNE   WBYTE1        nouvelle boucle
  ORB   #$40          set bit 6
  STB   <$CC          keep the DIN high
  PULS  B,PC          retour

*------------------------------------------------------
* LECTURE D'UN OCTET AVEC ALIGNEMENT SUR BIT 0 (SDMOTO)
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
ALIGN
  CLRA                compteur pour 256 boucles
ALIGN1
  LDB   #$7F          Valeur pour test bit 7
  STB   <$CC          clock high, di high 
  CMPB  <$CC          PA b7 (bit lu) -> carry 
  LDB   #$5F          clear bit 5
  STB   <$CC          clock low, di high
  BCS   ALIGN2        si bit 1, continuer a lire
  LDA   #$FC          sinon stocker bit 0
  BRA   RBYTE1        lire les 7 autres bits
ALIGN2
  DECA                decrementer compteur
  BNE   ALIGN1        nouvelle lecture

*------------------------------------------------------
* LECTURE D'UN OCTET (SDMOTO)
* 2 + 8 * 21 + 5 = 175 cycles
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation du compteur de boucle par Samuel
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
RBYTE
  LDA   #$FE          b0 marqueur fin de boucle (2)
RBYTE1      
  LDB   #$7F          Valeur pour test bit 7    (2)
  STB   <$CC          clock high, di high       (4)
  CMPB  <$CC          PA b7 (bit lu) -> carry   (4)
  LDB   #$5F          clear bit 5               (2)
  STB   <$CC          clock low, di high        (4)
  ROLA                C (bit lu) -> b0 reg A    (2)
  BCS   RBYTE1        suite de la boucle        (3) 
  RTS                 retour (octet dans A)     (5)

 ELSE
*------------------------------------------------------
* ECRITURE D'UN OCTET POUR SDMO
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en entree
*------------------------------------------------------
WBYTE
  LDB   #$08          compteur de boucles = 8
  PSHS  B             empilage compteur de boucles
WBYTE1
  LDB   <$C0          lecture port A
  ORB   #$40          b6=1 set DIN
  DEC   ,S            decremente compteur boucles
  BMI   WBYTE3        fin de la boucle
  ASLA                store bit to C
  BCS   WBYTE2        bit=1
  ANDB  #$BF          b6=0 clear DIN
WBYTE2
  STB   <$C0          DIN
  LDB   #$3E          set bit 3
  STB   <$C2          clock high 
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  BRA   WBYTE1        nouvelle boucle
WBYTE3
  STB   <$C0          keep the DIN high
  PULS  B,PC          retour

*------------------------------------------------------
* LECTURE D'UN OCTET AVEC ALIGNEMENT SUR BIT 0 (SDMO)
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
ALIGN
  CLRA                compteur pour 256 boucles
ALIGN1
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          read bit (PA bit 7) dans CC
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  BCS   ALIGN2        si bit 1, continuer a lire
  LDA   #$FC          stocker le bit 0
  BRA   RBYTE1        lire les 7 autres bits
ALIGN2       
  DECA                decrementer compteur
  BNE   ALIGN1        nouvelle lecture

*------------------------------------------------------
* LECTURE D'UN OCTET (SDMO)
* 2 + 8 * 21 + 5 = 175 cycles
* Le registre B n'est pas préservé
* Valeur de l'octet dans le registre A en sortie
* Optimisation du compteur de boucle par Samuel
* Optimisation transfert b7 avec CMPB par Daniel
*------------------------------------------------------
RBYTE
  LDA   #$FE          b0 marqueur fin de boucle (2)
RBYTE1      
  LDB   #$7F          set bit 3                 (2)  
  STB   <$C2          clock high                (4)
  CMPB  <$C0          read bit (PA b7) dans CC  (4) 
  LDB   #$36          clear bit 3               (2)
  STB   <$C2          clock low                 (2)
  ROLA                C (bit lu) -> b0 reg A    (2)
  BCS   RBYTE1        suite de la boucle        (3) 
  RTS                 retour (octet dans A)     (5)
 ENDIF

*------------------------------------------------------
* Calcul du LBA carte SD : SD_LBA =
* SD_LBA0+(512-511*SD_TYP)*(1280*DK_DRV+16*DK_TRK+DK_SEC-1)
* DK_DRV  n° lecteur de disquette
* DK_TRK  n° piste (2 octets)
* DK_SEC  n° secteur
* SD_TYP  type SD/SDHC
* Routine écrite par Samuel
*------------------------------------------------------
SETLBA
  PSHS  U,X,B,A
  LEAU  SD_LBA,PCR
  LDB   <DK_TRK+1  numero de piste
  CMPB  #$50       test piste 80
  BHS   SETLB8     erreur de piste
  LDA   #16
  MUL           ; voir avec lslb rola si les cycles sont importants
  TFR   D,X     ; x = DK_TRK*16
  LDB  <DK_SEC
  CMPB  #$10       test secteur 16
  BHI   SETLB9     erreur de secteur
  DECB
  ABX          ; x = DK_TRK*16 + DK_SEC - 1
  CLRA         ; plus lent que ldd #0, mais 1 octet de moins
  CLRB         
  STD  ,U
  LDA  <DK_DRV
  CMPA  #$04       test unite 4
  BHS   SETLB8     erreur d'unite
  LSLA
  LSLA
  ADDA <DK_DRV
  LEAX D,X     ; x = 1280 * DK_DRV + 16 * DK_TRK + DK_SEC - 1
  TFR  X,D
; la multiplication par 512-511*SD_TYP
  LEAX 4,U
  TST  <SD_TYP
  BNE  SETLB2
  LSLB        
  ROLA        
  CLR  ,-X    
SETLB2
  STD  -2,X   ; <--+  u pointe sur SD_LBA = 0 XX XX 0 ou 0 0 XX XX
; SD_LBA = SD_LBA + SD_LB0 sur 32bits
  LDD  <SD_LB0+2
  ADDD 2,U      
  STD  2,U
  LDD  <SD_LB0
  ADCB 1,U
  ADCA #0    ; en vrai ",u" mais c'est équivalent car on a toujours 0 à cette adresse
  STD  ,U
  CLRB
  PULS  A,B,X,U,PC  retour OK
SETLB8  
  LBSR  ERR02       erreur de piste  
  PULS  A,B,X,U,PC  retour en erreur
SETLB9  
  LBSR  ERR04       erreur de secteur  
  PULS  A,B,X,U,PC  retour en erreur
  
*------------------------------------------------------
* Lecture d'un secteur
*------------------------------------------------------
SREAD
  BSR   SETLBA     calcul SD_LBA
  LBCS  SREAD9     erreur unite/piste/secteur 
SREAD1  
  LDA   #$51       code CMD17
  STA   <CMDXX     initialise le code commande  
  LDY   <DK_BUF    adresse du buffer
  LBSR  SCONF      configuration pour acces carte SD 
  LEAU  CMDXX,PCR  adresse CMD17
  LBSR  EXCMD      execution CMD17 
SREAD2
  BSR   RBYTE      lecture d'un octet
  CMPA  #$FE       comparaison avec $FE
  BNE   SREAD2     attente debut secteur
* lire 256 octets
  CLRA             compteur pour 256 boucles 
  PSHS  A          empilage du compteur
SREAD3

 IF &BANK=0
* lecture d'un octet dans A (SDMOTO) *******************
* premier bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* deuxieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* troisieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* quatrieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* cinquieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* sixieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* septieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
* huitieme bit
  LDB   #$7F       Valeur pour test bit 7    (2)
  STB   <$CC       clock high, di high       (4)
  CMPB  <$CC       PA b7 (bit lu) -> carry   (4)
  LDB   #$5F       clear bit 5               (2)
  STB   <$CC       clock low, di high        (4)
  ROLA             C (bit lu) -> b0 reg A    (2)
********************************************************
 ELSE
* lecture d'un octet dans A (SDMO) *********************
* premier bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* deuxieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* troisieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* quatrieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* cinquieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* sixieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* septieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
* huitieme bit
  LDB   #$7F          set bit 3
  STB   <$C2          clock high 
  CMPB  <$C0          PA b7 (bit lu) -> carry
  LDB   #$36          clear bit 3
  STB   <$C2          clock low
  ROLA                C (bit lu) -> b0 reg A    (2)
********************************************************
 ENDIF

  STA   ,Y+        stockage dans le buffer
  DEC   ,S         decrementation compteur 
  BNE   SREAD3     nouvelle lecture
  PULS  A          depilage compteur 
* ignorer 256 octets
  BSR  CLOCK       envoi de 256 * 8 tops
* ignorer 2 octets de CRC
  LDA   #$02       pour 2 octets
  BSR   CLOCK      ignorer 2 octets
  LBSR  RCONF      retablissement configuration 
SREAD9
  RTS              retour 

 IF &BANK=0
*------------------------------------------------------
* ENVOI DE TOPS HORLOGE (8 fois reg A) (SDMOTO)
*------------------------------------------------------
CLOCK
  PSHS  A
  LDD   #$7F5F
CLOCK1
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  STA   <$CC          clock high, di high
  STB   <$CC          clock low, di high 
  DEC   ,S
  BNE   CLOCK1                            
  PULS  A,PC                                      
 ELSE
*------------------------------------------------------
* ENVOI DE TOPS HORLOGE (8 fois reg A) (SDMO)
*------------------------------------------------------
CLOCK
  PSHS  A
  LDD   #$3E36
CLOCK1
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  STA   <$C2          clock high, di high
  STB   <$C2          clock low, di high 
  DEC   ,S
  BNE   CLOCK1                            
  PULS  A,PC                                      
 ENDIF
    
*------------------------------------------------------
* Ecriture d'un secteur disquette
* dans secteur SD complete a 512
*------------------------------------------------------
SWRITE
  LBSR  WPROT      test protection ecriture             
  LBLO  SWRIT9     branchement si protection
  LBSR  SETLBA     calcul SD_LBA
  LBCS  SWRIT9     erreur unite/piste/secteur
  LDA   #$58       code CMD24
  STA   <CMDXX     initialise code commande  
  LDY   <DK_BUF    adresse du buffer
  LBSR  SCONF      configuration pour acces carte SD 
  LEAU  CMDXX,PCR  adresse CMD24
  LBSR  EXCMD      execution CMD24 
  LDA   #$FE       indicateur debut bloc 
  LBSR  WBYTE      ecriture de l'octet
* ecrire 256 octets du buffer
  CLRA             compteur pour 256 boucles 
  PSHS  A          empilage du compteur octets
SWRIT2
  LDA   ,Y+        lecture dans le buffer

 IF &BANK=0
* ecriture de l'octet A pour SDMOTO ***************
* premier bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* deuxieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* troisieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* quatrieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* cinquieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* sixieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* septieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* huitieme bit
  ASLA             b7 reg A -> carry
  RORB             carry -> b7 reg B
  LSRB             b7 reg B -> b6 reg B
  STB   <$CC       envoi bit vers DI
  ORB   #$20       set bit 5
  STB   <$CC       clock high
  ANDB  #$DF       clear bit 5
  STB   <$CC       clock low
* set DIN high
  ORB   #$40       set bit 6
  STB   <$CC       keep the DIN high
* test fin de secteur
  DEC   ,S         decrementation compteur octets
  BNE   SWRIT2     nouvelle ecriture
***************************************************
 ELSE
* ecriture de l'octet A pour SDMO *****************
* premier octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* deuxieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* troisieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* quatrieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* cinquieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* sixieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* septieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* huitieme octet
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  ASLA             store bit to C
  BCS   *+4        bit=1
  ANDB  #$BF       b6=0 clear DIN
  STB   <$C0       DIN
  LDB   #$3E       set bit 3
  STB   <$C2       clock high 
  LDB   #$36       clear bit 3
  STB   <$C2       clock low
* set DIN high
  LDB   <$C0       lecture port A
  ORB   #$40       b6=1 set DIN
  STB   <$C0       keep the DIN high
* test fin de secteur
  DEC   ,S         decrementation compteur octets
  LBNE  SWRIT2     nouvelle ecriture
***************************************************
 ENDIF
  
  PULS  A          depilage compteur octets 
* ecrire 256 octets $FF
  LBSR  CLOCK      ecrire 256 octets $FF
* ecrire 2 octets de CRC $FF
  LDA   #$02       pour 2 octets
  LBSR  CLOCK      envoi 2 fois 8 tops horloge
  LBSR  RCONF      retablissement configuration 
SWRIT9
  RTS   

*------------------------------------------------------
* Teste la protection ecriture
*------------------------------------------------------
WPROT
  CLRA  
  RTS   

*------------------------------------------------------
* Retour d'un code erreur
*------------------------------------------------------
ERRSET
  STA   <DK_STA
  COMA  
  RTS   

*------------------------------------------------------
* Erreur de secteur
*------------------------------------------------------
ERR04
  LDA   #$04
  BRA   ERRSET

*------------------------------------------------------
* Erreur sur les donnees
*------------------------------------------------------
ERR08
  LDA   #$08
  BRA   ERRSET

*------------------------------------------------------
* Erreur de piste
*------------------------------------------------------
ERR02
  LDA   #$02
  BRA   ERRSET

*------------------------------------------------------
* Recherche piste
*------------------------------------------------------
FINDT
  CLRA
  RTS                    retour

*------------------------------------------------------
* Test presence disquette
*------------------------------------------------------
TSTDSK
  CLRA  
  RTS

*------------------------------------------------------
* Recherche piste 0
*------------------------------------------------------
FIND0
  CLRA
  RTS   

*------------------------------------------------------
* DKFMT = formatage de la disquette
*------------------------------------------------------
DKFMT
  PSHS  U,Y,X,DP,B,A,CC              
  ORCC  #$50          desactive les interruptions 
  LBSR  INIREG
*  LBSR  INIOP
*  BSR   INIDEN
*  LBSR  WPROT
*  BLO   DKFMT9  
*  BSR   FIND0      Recherche piste 0
*  BLO   DKFMT9 
  CLR   <DK_TRK       
  CLR   <DK_TRK+1       
DKFMT1
  LBSR  FMTRK      formatage d'une piste 
*  LBSR  FMTVT      verification piste formatee
*  BHS   DKFMT9     erreur de verification

* LDA   <DK_TRK+1  numero de piste
* CMPA  #$4F       derniere piste = 79
* BEQ   DKFMT4     fin de disquette
* INCA             incrementation n° piste
* STA   <DK_TRK+1  stockage n° piste
* BRA   DKFMT1     piste suivante
DKFMT4
  LBSR  INIT20     initialisation piste 20 
  BLO   DKFMT9 
* LDA   #$28       piste 40   pourquoi ???    
* STA   <DK_TRK+1  stockage n° piste          
DKFMT9
  PULS  A 
  EXG   A,CC
  LSRA  
  PULS  A,B,DP,X,Y,U,PC

*------------------------------------------------------
* Initialisation pour operation
*------------------------------------------------------
*INIOP
*  LDA   <DK_OPC
*  ANDA  #$80
*  STA   <DK_OPC
*  CLR   <DK_STA
*  RTS   

*------------------------------------------------------
* Selection densite du logiciel
*------------------------------------------------------
INIDEN
  RTS
  
*------------------------------------------------------
* Formatage d'une piste
*------------------------------------------------------
FMTRK
  LDA   #$E5       caractere de remplissage
  BSR   INIBUF     remplissage buffer
  LDA   #$01       numero premier secteur
  STA   <DK_SEC    stockage numero secteur         
FMTRK1
  LBSR  SWRITE     ecriture d'un secteur
  LDA   <DK_SEC    numero de secteur
  CMPA  #$10       secteur 16
  BEQ   FMTRK9     fin de piste
  INCA             incrementation secteur
  STA   <DK_SEC    stockage numero secteur
  BRA   FMTRK1     secteur suivant
FMTRK9
  RTS              retour
  
*------------------------------------------------------
* Verification piste formatee
*------------------------------------------------------
FMTVT
  CLRA  
  RTS   
  
*------------------------------------------------------
* Remplissage du buffer de secteur
*------------------------------------------------------
INIBUF
  LDY   <DK_BUF    initialisation adresse
  CLRB             nombre octets secteur
INIB1
  STA   ,Y+        stockage octet remplissage
  DECB             decrementation compteur
  BNE   INIB1      octet suivant 
  RTS              retour
  
*------------------------------------------------------
* Initialisation piste 20
*------------------------------------------------------
INIT20
  LDX   #$0014     piste 20 
  STX   <DK_TRK
  LDA   #$FF       valeur de remplissage
  BSR   INIBUF     remplissage buffer
  LDA   #$08
  ORA   <DK_OPC
  STA   <DK_OPC
  CLRB             initialisation n° secteur
INIT21
  INCB             secteur suivant
  STB   <DK_SEC
  LBSR  DKCONT     ecriture du secteur
  BLO   INIT29
  CMPB  #$10       secteur 16
  BNE   INIT21
  LDX   <DK_BUF
  CLR   ,X         premier octet FAT = 0
  LDD   #$FEFE     blocs reserves
  STD   $29,X      pour piste 20
  LDA   #$02
  STA   <DK_SEC
  LBSR  DKCONT     ecriture du secteur
  BLO   INIT29     retour en erreur
  CLRA             pas d'erreur
INIT29
  RTS   

*------------------------------------------------------
* SCRATCH DOS
*------------------------------------------------------
SCRDOS
  FCC   "SCRATCH"
  FCC   " DOS"

*------------------------------------------------------
* FINTR = cloture d'ecriture
*------------------------------------------------------
FINTR
  LDB   <DKWF0     code operation logique   
  CMPB  #$02
  BEQ   FINTR3 
  DEC   <DKWF0     code operation logique
  BSR   RECFI      ouverture fichier
  BLO   FINTR9
  TSTB  
  BEQ   FINTR1
  LBSR  RECUP
  BLO   FINTR9
FINTR1
  INC   <DKWF0     code operation logique
  BSR   RECFI
  BLO   FINTR9
  LDB   #$0a
  LDX   <DKWE7
FINTR2
  LDA   B,X
  STA   B,Y
  DECB  
  BGE   FINTR2
  BSR   ECRSE      ecriture secteur
  BLO   FINTR9
****************** sauvegarde de la FAT
FINTR3
  LDA   #$02
  STA   <DK_SEC    secteur 2
  LDB   #$14
  CLRA  
  STD   <DK_TRK    piste 20
  LDD   <DKWED     adresse de la FAT
  STD   <DK_BUF    adresse du buffer secteur
  BSR   ECRSE      ecriture secteur
  BLO   FINTR9     erreur ecriture
  CLR   <$f0       indicateur cloture fichier
FINTR9
  RTS   

*--------------------------------
* LECFA = Lecture de la FAT
*------------------------------------------------------
LECFA
  LDX   <DKWED     adresse de la FAT
  STX   <DK_BUF    adresse du buffer secteur
  LDA   #$02       numero secteur a lire
  BRA   LSEC20     lecture secteur piste 20

*------------------------------------------------------
* Sortie en erreur
*------------------------------------------------------
RETERR
  STA   <DKWE5
  COMA  
  COMA  
  RTS   

*------------------------------------------------------
* Sortie sans erreur
*------------------------------------------------------
RETOK
  CLRA  
  RTS   

*------------------------------------------------------
* Chargement 1er secteur catalogue
*------------------------------------------------------
LDIR0
  LDA   #$03
  LDX   <DKWE9     pointeur sur buffer
  STX   <DK_BUF

*------------------------------------------------------
* Chargement secteur piste 20
*------------------------------------------------------
LSEC20
  STA   <DK_SEC
  LDB   #$14
  CLRA  
  STD   <DK_TRK
  LDA   #$02
  BRA   SECTIO

*------------------------------------------------------
* ECRSE = Ecriture d'un secteur
*------------------------------------------------------
ECRSE
  LDA   #$08

*------------------------------------------------------
* Operation sur secteur
*------------------------------------------------------
SECTIO
  STA   <DK_OPC
  LDY   <DKWE9     pointeur sur buffer
  LBSR  OPTABL
  LDA   #$03
  RTS   

*------------------------------------------------------
* RECFI = Ouverture d'un fichier
*------------------------------------------------------
RECFI
  BSR   LDIR0      charge 1er secteur catalogue 
RECFI1
  BLO   RETERR     sort si erreur
  LDX   #$0008     compteur de noms dans X
  LDY   <DKWE9     pointeur sur buffer
RECFI2
  LDU   <DKWE7
  LDB   <DKWF0     code operation logique
  CMPB  #$03
  BNE   RECFI3
  LEAU  SCRDOS,PCR adresse du nom de fichier
RECFI3
  CLRB  
RECFI4
  CMPB  #$0b
  BHS   RECFI8
  LDA   B,Y
  CMPA  #$ff
  BEQ   RECFI7
  INCB  
  CMPA  ,U+
  BEQ   RECFI4
  LEAY  $20,Y
  LEAX  -$01,X
  BNE   RECFI2
  INC   <DK_SEC
  LDA   <DK_SEC
  CMPA  #$10
  BHI   RECFI7
  LBSR  OPTABL
  LDA   #$03          erreur I/O
  BRA   RECFI1
RECFI7
  CLRB  
  BRA   RECFI9
RECFI8
  LDB   $0b,Y
  CMPB  <DKWEB
  BNE   RECFI7
  LDB   $0c,Y
  CMPB  <DKWEC
  BNE   RECFI7
  LDB   <DK_SEC
  LDA   $0d,Y
  STA   <DKWF6
  CLR   <DKWF5
  LDX   $0e,Y
  STX   <DKWF7
  STY   <DKWFA
RECFI9
  STB   <DKWF9     numero de bloc alloue
  BRA   RETOK

*------------------------------------------------------
* ALLOD = allocation d'un fichier
*------------------------------------------------------
ALLOD
  LDY   <DKWED     adresse de la FAT
  BSR   ALLOB4     test place libre
ALLOD1
  BLO   RECFI1     erreur plus de place
  STB   <DKWF6     numero de bloc
  LBSR  LDIR0      charge debut directory
ALLOD2  
  BLO   ALLOD1     sortie en erreur
  LDY   <DKWE9     pointeur sur buffer
  LDX   #$0008     compteur de noms dans X
ALLOD3
  LDB   ,Y         premier octet du nom 
  BEQ   ALLOD6     0=fichier efface
  LDA   #$05
  CMPB  #$ff
  BEQ   ALLOD6
  LEAY  $20,Y
  LEAX  -$01,X
  BNE   ALLOD3
  INC   <DK_SEC
  LDA   <DK_SEC
  CMPA  #$10
  BHI   ALLOD4
  LBSR  OPTABL     charge le secteur suivant 
  LDA   #$03
  BRA   ALLOD2
ALLOD4
  LDA   #$05       code "disque plein"
ALLOD5
  BRA   ALLOD1     sort avec erreur
ALLOD6
  LDX   <DKWE7
  LDB   <DKWF0     code operation logique
  CMPB  #$03
  BNE   ALLOD7
  LEAX  SCRDOS,PCR adresse nom de fichier
ALLOD7
  LDB   #$0a
ALLOD8
  LDA   B,X        recopie le nom de fichier
  STA   B,Y        dans le catalogue
  DECB  
  BGE   ALLOD8
  LDA   <DKWEB     type de fichier 
  STA   $0b,Y
  LDA   <DKWEC     recopie le numero de bloc
  LDB   <DKWF6     dans le catalogue
  STD   $0c,Y
  LBRA  ECRSE      ecriture du repertoire

*------------------------------------------------------
* ALLOB = allocation d'un bloc
*------------------------------------------------------
ALLOB
  LDB   <DKWF6     numero de bloc
  CMPB  #$50
  BHI   ALLOB3
ALLOB1
  TSTB  
ALLOB2
  BEQ   ALLOB4
  LDA   B,Y
  CMPA  #$ff
  BEQ   ALLOB8
  DECB  
  CMPB  #$50
  BLS   ALLOB1
ALLOB3
  ADDB  #$02
  CMPB  #$A1
  BRA   ALLOB2
ALLOB4
  LDB   #$50  
ALLOB5
  LDA   #$05
  CMPB  #$A0
  LBHI  RETERR
  LDA   B,Y
  CMPA  #$ff
  BEQ   ALLOB8
  PSHS  B
  SUBB  #$50
  NEGB  
  ADDB  #$50
  LDA   B,Y
  CMPA  #$ff
  BEQ   ALLOB6
  PULS  B  
  INCB  
  BRA   ALLOB5
ALLOB6
  LEAS  $01,S 
ALLOB8
  CLR   B,Y
  DECB  
  STB   <DKWF9     numero de bloc alloue
ALLOB9
  LBRA  RETOK

*------------------------------------------------------
* RECUP = liberation d'un bloc
*------------------------------------------------------
RECUP
  LDA   $0d,Y
  STA   <DKWF6     numero de bloc
  CLR   ,Y
  LBSR  ECRSE
  BLO   ALLOD5
  LDY   <DKWED
  LDB   <DKWF6     numero de bloc
RECUP1
  INCB  
  LDA   B,Y
  CLR   B,Y
  DEC   B,Y
  TFR   A,B
  CMPA  #$c0
  BLO   RECUP1
  BRA   ALLOB9

*------------------------------------------------------
* MAJCL = Mise a jour cluster
*------------------------------------------------------
MAJCL
  LDB   <DKWF6       numero bloc                              
  CLRA  
  LSRB               divise par 2
  STD   <DKWFB       numero piste
  INCA  
  STA   <DKWF5
  BHS   MAJCL9 
  LDA   #$09   
MAJCL9
  STA   <DKWFA 
  RTS   

*------------------------------------------------------
* COMMANDES CARTE SD
*------------------------------------------------------
CMD0
  FCB   $40           go iddle state
  FDB   $0000
  FDB   $0000
  FCB   $95           checksum obligatoire           
  FCB   $01           code retour attendu  
*------------------------------------------------------
CMD8
  FCB   $48           send interface condition
  FDB   $0000
  FDB   $01AA
  FCB   $87           checksum obligatoire  
  FCB   $00           code retour attendu  
*------------------------------------------------------
CMD55
  FCB   $77           application command
  FDB   $0000
  FDB   $0000
  FCB   $FF           checksum non testee  
  FCB   $00           code retour attendu  
*------------------------------------------------------
AC41
  FCB   $69           activate card initialization 
  FDB   $4000
  FDB   $0000 
  FCB   $FF           checksum non testee  
  FCB   $00           code retour attendu  
*------------------------------------------------------
CMD58
  FCB   $7A           read OCR
  FDB   $0000
  FDB   $0000
  FCB   $FF           checksum non testee
  FCB   $00           code retour attendu  
*------------------------------------------------------
 
  END